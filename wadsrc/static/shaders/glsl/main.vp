
out vec4 pixelpos;

// This is for the colormap shader which doesn't implement any form of lighing special effects.	
#ifndef NO_LIGHTING
	in vec4 fogparams;
	out vec4 fogparm;
	out vec2 glowdist;
	uniform vec4 glowbottomplane, glowtopplane;
	in float lightlevel_in;
	out float lightlevel;
#endif


// valid colorcontrol modes are:
//
// 0: read color and alpha from attribute, no desaturation
// 1: read color from buffer, alpha from attribute and no desaturation
// 2: read color and alpha from buffer. If alpha is 0, bufferColor will be an index into the parameter buffer with 2 entries defining RGBA and desaturation
uniform int colorcontrol;
in vec4 attribColor;
uniform int bufferColor;	// as AARRGGBB, 8 bits each.
out float desaturation_factor;


uniform mat4 ModelMatrix;
//uniform mat4 ViewMatrix;
//uniform mat4 ProjectionMatrix;
uniform mat4 TextureMatrix;


//--------------------------
//
// converts an integer with AARRGGBB value to a vec4.
// These values are used to keep buffer size low. 
// (We got more than enough shader performance to burn so the bandwidth savings are definitely worth it.)
//
//--------------------------

vec4 int2vec4(int value)
{
	vec4 color;
	
	color.a = float((value >> 24) & 0xff)/ 255.0;
	color.r = float((value >> 16) & 0xff)/ 255.0;
	color.g = float((value >> 8) & 0xff) / (255.0);
	color.b = float(value & 0xff)/ 255.0;
	return color;
}

void main()
{
	vec4 worldcoord = ModelMatrix * gl_Vertex;
	vec4 eyeCoordPos = ViewMatrix * worldcoord;

	//--------------------------
	//
	// process the color
	//
	//--------------------------
	vec4 color;
	switch (colorcontrol)
	{
		case 0:
			color = attribColor;
			break;
			
		case 1:
			// int bufferColor = parambuffer[pb_index].bufferColor;
			color = int2vec4(bufferColor);
			color.a = attribColor.a;
			break;
			
		case 2:
			color = int2vec4(bufferColor);
			break;
	}
	gl_FrontColor = color;
	desaturation_factor = 0.0;//fixme! desaturate;
	
	//--------------------------
	//
	// end of color processing
	//
	//--------------------------

	pixelpos.xyz = worldcoord.xyz;
	pixelpos.w = -eyeCoordPos.z/eyeCoordPos.w;
	
	#ifndef NO_LIGHTING
		lightlevel = lightlevel_in;
		fogparm = fogparams;
		// set glow distance from the sector's plane equations so that we do not have to do this on the CPU and pass additional vertex ins to the shader.
		glowdist.x = -((glowtopplane.w + glowtopplane.x * worldcoord.x + glowtopplane.y * worldcoord.z) * glowtopplane.z) - worldcoord.y;
		glowdist.y = worldcoord.y + ((glowbottomplane.w + glowbottomplane.x * worldcoord.x + glowbottomplane.y * worldcoord.z) * glowbottomplane.z);
	#endif
	
	#ifdef SPHEREMAP
		vec3 u = normalize(eyeCoordPos.xyz);
		vec3 n = normalize(gl_NormalMatrix * gl_Normal);
		vec3 r = reflect(u, n);
		float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
		vec2 sst = vec2(r.x/m + 0.5,  r.y/m + 0.5);
		gl_TexCoord[0].xy = sst;
	#else
		gl_TexCoord[0] = TextureMatrix * gl_MultiTexCoord0;
	#endif
	
	
	gl_Position = ProjectionMatrix * eyeCoordPos;
}
