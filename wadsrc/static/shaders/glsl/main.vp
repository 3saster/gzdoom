
out vec4 pixelpos;

// This is for the colormap shader which doesn't implement any form of lighing special effects.	
#ifndef NO_LIGHTING
	in vec4 fogparams;
	out vec4 fogparm;
	out vec2 glowdist;
	uniform vec4 glowbottomplane, glowtopplane;
	in float lightlevel_in;
	out float lightlevel;
#endif


uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 TextureMatrix;


/*
uniform int ColorFromBuffer;
*/

void main()
{
	vec4 worldcoord = ModelMatrix * gl_Vertex;
	vec4 eyeCoordPos = ViewMatrix * worldcoord;

	/*
		if (ColorFromBuffer != 0)
		{
			gl_FrontColor = [color value from buffer];
		}
		else
	*/
		{
			gl_FrontColor = gl_Color;
		}

	pixelpos.xyz = worldcoord.xyz;
	pixelpos.w = -eyeCoordPos.z/eyeCoordPos.w;
	
	#ifndef NO_LIGHTING
		lightlevel = lightlevel_in;
		fogparm = fogparams;
		// set glow distance from the sector's plane equations so that we do not have to do this on the CPU and pass additional vertex ins to the shader.
		glowdist.x = -((glowtopplane.w + glowtopplane.x * worldcoord.x + glowtopplane.y * worldcoord.z) * glowtopplane.z) - worldcoord.y;
		glowdist.y = worldcoord.y + ((glowbottomplane.w + glowbottomplane.x * worldcoord.x + glowbottomplane.y * worldcoord.z) * glowbottomplane.z);
	#endif
	
	#ifdef SPHEREMAP
		vec3 u = normalize(eyeCoordPos.xyz);
		vec3 n = normalize(gl_NormalMatrix * gl_Normal);
		vec3 r = reflect(u, n);
		float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
		vec2 sst = vec2(r.x/m + 0.5,  r.y/m + 0.5);
		gl_TexCoord[0].xy = sst;
	#else
		gl_TexCoord[0] = TextureMatrix * gl_MultiTexCoord0;
	#endif
	
	
	gl_Position = ProjectionMatrix * eyeCoordPos;
}
