
out vec4 pixelpos;

in vec4 fogparams;
out vec4 fogcolor;
out vec4 fogparm;
out vec2 glowdist;
out vec4 topglowcolor;
out vec4 bottomglowcolor;
flat out ivec4 lightrange;
in float lightlevel_in;
out float lightlevel;


// valid colorcontrol modes are:
//
// 0: read color and alpha from attribute, no desaturation
// 1: read color from buffer, alpha from attribute and no desaturation
// 2: read color and alpha from buffer. If alpha is 0, bufferColor will be an index into the parameter buffer with 2 entries defining RGBA and desaturation
uniform int colorcontrol;

layout (location=11) in vec4 attribColor;
layout (location=12) in int attribindex;

//uniform int bufferColor;	// as AARRGGBB, 8 bits each.
out float desaturation_factor;


//--------------------------
//
// converts an integer with AARRGGBB value to a vec4.
// These values are used to keep buffer size low. 
// (We got more than enough shader performance to burn so the bandwidth savings are definitely worth it.)
//
//--------------------------

vec4 int2vec4(int value)
{
	vec4 color;
	
	color.a = float((value >> 24) & 0xff)/ 255.0;
	color.r = float((value >> 16) & 0xff)/ 255.0;
	color.g = float((value >> 8) & 0xff) / (255.0);
	color.b = float(value & 0xff)/ 255.0;
	return color;
}

void main()
{
	vec4 worldcoord = ModelMatrix * gl_Vertex;
	vec4 eyeCoordPos = ViewMatrix * worldcoord;

	//--------------------------
	//
	// process the color
	//
	//--------------------------
	vec4 color;
	switch (colorcontrol)
	{
		default:
		case 0:	// color comes from vertex attribute
			color = attribColor;
			break;
			
		case 1:	// color comes from attribute buffer, alpha from vertex attribute
			color = int2vec4(Attribs[attribindex].aColor);
			color.a = attribColor.a;
			break;
			
		case 2:	// color comes from attribute buffer
			color = int2vec4(Attribs[attribindex].aColor);
			break;
	}
	gl_FrontColor = color;
	
	vec4 fc = int2vec4(Attribs[attribindex].aFogColor);
	if (fc.a != 0.0)
	{
		if (fc.rgb == vec3(0.0)) fc.a = 1.0;
		else fc.a = -1.0;
	}
	else
	{
		fc = vec4(0.0);
	}
	fogcolor = fc;
	
	desaturation_factor = 0.0;//fixme! desaturate;
	
	//--------------------------
	//
	// end of color processing
	//
	//--------------------------

	pixelpos.xyz = worldcoord.xyz;
	pixelpos.w = -eyeCoordPos.z/eyeCoordPos.w;
	
	lightlevel = lightlevel_in;
	fogparm = fogparams;
	// set glow distance from the sector's plane equations so that we do not have to do this on the CPU and pass additional vertex ins to the shader.
	int glowindex = Attribs[attribindex].aGlowIndex;
	if (glowindex != -1)
	{
		topglowcolor = Parameters[glowindex];
		bottomglowcolor = Parameters[glowindex+1];
		vec4 glowtopplane = Parameters[glowindex+2];
		vec4 glowbottomplane = Parameters[glowindex+3];
		glowdist.x = -((glowtopplane.w + glowtopplane.x * worldcoord.x + glowtopplane.y * worldcoord.z) * glowtopplane.z) - worldcoord.y;
		glowdist.y = worldcoord.y + ((glowbottomplane.w + glowbottomplane.x * worldcoord.x + glowbottomplane.y * worldcoord.z) * glowbottomplane.z);
	}
	else
	{
		topglowcolor = vec4(0.0);
		bottomglowcolor = vec4(0.0);
		glowdist = vec2(0.0);
	}
	
	int dlights = Attribs[attribindex].aLightIndex;
	if (dlights != -1)
	{
		lightrange = ivec4(Parameters[dlights]);
	}
	else
	{
		lightrange = ivec4(0);
	}
	
	#ifdef SPHEREMAP
		vec3 u = normalize(eyeCoordPos.xyz);
		vec3 n = normalize(gl_NormalMatrix * gl_Normal);
		vec3 r = reflect(u, n);
		float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
		vec2 sst = vec2(r.x/m + 0.5,  r.y/m + 0.5);
		gl_TexCoord[0].xy = sst;
	#else
		int texmat = Attribs[attribindex].aMatIndex;
		if (texmat != -1)
		{
			mat4 TextureMatrix = mat4(Parameters[texmat], Parameters[texmat+1], Parameters[texmat+2], Parameters[texmat+3]);
			gl_TexCoord[0] = TextureMatrix * gl_MultiTexCoord0;
		}
		else
		{
			gl_TexCoord[0] = gl_MultiTexCoord0;
		}
	#endif
	
	
	gl_Position = ProjectionMatrix * eyeCoordPos;
}
